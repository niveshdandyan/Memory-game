import os
import time
import random

# Determine the clear command based on the operating system
if os.name == 'nt':
    clear = "cls"
else:
    clear = "clear"
    

def main():
    video_link = "https://www.youtube.com/watch?v=l1FXdjS7S0Y"  # Link to how to play video
    trailer = "https://www.youtube.com/watch?v=DyfXOTL6__4" # Link to trailer
    os.system(clear) # Clear the screen
    title_display()
    _ = input()
    rolling("WELCOME TO MEMORY MASTER")
    time.sleep(0.5)
    rolling("ENTER CORRESPONDING NUMBER FOR YOUR CHOICE")

    while True:
        os.system(clear)  # Clear the screen for the main menu
        mainscreen_display()  # Display the main menu 
        choice = input("Choice: ")
        match choice:
            case "0":  # Exit option
                break
            case "1": # Start game
                level_display()  # Display level options
                match input("Level: "):
                    case "1":
                        easy()
                    case "2":
                        medium()
                    case "3":
                        hard()
                    case _:
                        pass # if Invalid input, do nothing
                _ = input("PRESS ENTER TO BACK TO TITLE") # Return to title screen

            case "2": # Customize game
                os.system(clear)
                rows = get_input(list(range(1, 9)), "Rows(1~8): ") # Get number of rows
                cols = get_input(list(range(1, 9)), "Cols(1~8): ") # Get number of columns

                # Ensure rows * cols is even
                while (rows * cols % 2):
                    print("Sorry, rows*cols must be even")
                    rows = get_input(list(range(1, 9)), "Rows(1~8): ")
                    cols = get_input(list(range(1, 9)), "Cols(1~8): ")  

                random_swap = get_input(list(range(11)), "Random swap probability(0~10, 0 means no random swap): ") # Get random swap probability
                tornado = get_input(([0, 1]), "Tornado occurs?(0/1, 0 means no tornado): ") # Get tornado option
                hint = get_input(([0, 1]), "Any hints?(0/1, 0 means no hint): ") # Get hint option
                customize(rows, cols, random_swap, tornado, hint) # Customize the game
                _ = input("PRESS ENTER TO BACK TO TITLE")

            case "3": # Tutorial option
                os.system(clear)
                tutorial()

            case "4":  # How to play and trailer
                os.system("clear")
                print(f"HOW TO PLAY: {video_link}\n")
                print(f"TRAILER: {trailer}\n")
                _ = input("PRESS ENTER TO BACK TO TITLE")

def title_display():
    # Displays the game title screen with special effects.
    s='(^_^)PRESS ENTER TO START THE GAME(^_^)'
    title = open("title.bin") # The title document is generated by ChatGPT
    # colors_code = [0, 32, 34, 33, 30, 37, 0]
    # backgrounds = [0, 41, 43, 44, 47, 40, 0]
    color_code = 33
    for i, line in enumerate(title):
        time.sleep(0.5)
        print("\33[{code}m".format(code=color_code) + line + "\33[{code}m".format(code=0), end="")
    print("\33[{code}m".format(code=color_code) + s + "\33[{code}m".format(code=0), end="")

                                
def mainscreen_display():
    # Shows the main menu with choices for level selection, customization, tutorial, and video links.
    print("ENTER CORRESPONDING NUMBER FOR YOUR CHOICE\n")
    print("1: LEVELS")
    print("2: CUSTOMIZE")
    print("3. HOW TO PLAY")
    print("4: VIDEOS\n")
    print("0: END THE GAME\n")
    

def level_display():
    # Displays the available levels and a random tip or joke before selecting a difficulty level.
    sentences = ["Kindly reminder: If you cannot reveal any pairs, try wait for something special to happen",
    "Kindly reminder: Don't put yourself straight to hard level, try easy first!",
    "Kindly reminder: Maybe go through the tutorial before any gameplay start",
    "Fun fact: UEFA Euro 2020 is held in 2021",
    "Fun fact: Fridays increase happiness by 11% worldwide",
    "Fun fact: 'Whatever' has been voted the world's most hated word for three years in a row",
    "Fun fact: Bananas bend because they grow towards the sun",
    "Fun fact: Elephants are the only mammals that cannot jump",
    "Fun fact: Try to click in https://www.youtube.com/watch?v=dQw4w9WgXcQ, it will tell the answer of universe",
    "Fun fact: A cloud weighs around a million tonnes",
    "Fun fact: Lights take almost eight minutes to proceed from the sun to earth",
    "Stupid Joke: The past, the present, and the future walked into a bar. It was tense",
    "Stupid Joke: Can February March? No, but April May!",
    "Stupid Joke: Time flies like an arrow. Fruit flies like a banana",
    "Stupid Joke: What do you call a can opener that doesn't work? A can't opener",
    "Stupid Joke: Why did Shakespeare only write using pens? Pencils confused him. 2B or not 2B"]
    os.system(clear)
    print("1: EASY (4*3, WITH HINTS, NO TORNADO, NO RANDOM SWAP)")
    print("2: MEDIUM (4*4, WITH HINTS, WITH TORNADO, 20% RANDOM SWAP OCCUR)")
    print("3: HARD (4*6, NO HINTS, WITH TORNADO, 30% RANDOM SWAP OCCUR)")
    print("ANY OTHER THING: BACK TO TITLE")
    print("\nTip: You can enter '111' in your first reveal to exit the level during gameplay")
    print(f"\n{random.choice(sentences)}")

def get_input(field, string):
    # Prompts for and validates user input against a specific range or set of acceptable values.
    var = input(string)
    while var not in list(map(str, field)):
        print("Invalid, try again")
        var = input(string)
    return int(var)

def customize(rows, cols, prob, tornado, hint):
    # Starts a customizable game mode with user-defined board size and optional tornado, random swaps, and hints
    game = Game(rows=rows, cols=cols, seed=None)
    os.system(clear)
    while game.pairs != 0:
        game.board_print()
        f_reveal = input("First Reveal: ")
        if f_reveal == "111":
            os.system(clear)
            break
        while f_reveal not in game.pos_lst or f_reveal == "":
            os.system(clear)
            print("Invalid input, try again")
            game.board_print()
            f_reveal = input("First Reveal: ")

        os.system(clear)
        game.first_reveal(f_reveal)
        s_reveal = input("Next Reveal: ")
        while s_reveal not in game.pos_lst or s_reveal == "" or s_reveal == f_reveal:
            os.system(clear)
            print("Invalid input, try again")
            game.first_reveal(f_reveal)
            s_reveal = input("Next Reveal: ")

        os.system(clear)
        if game.second_reveal(f_reveal, s_reveal):
            if tornado:
                game.tornado_condition()
            _ = input("Press Enter to Continue")
        else:
            if tornado:
                if not game.tornado_condition():
                    game.switch_condition(prob)
            else:
                game.switch_condition(prob)
            _ = input("Finish memorizing?(Press Enter to Continue)")
        os.system(clear)

        y_n = ""
        if game.hint_check() and hint:
            y_n = input("It seems like you are in trouble, do you want some hints?[y/n]")
            game.hint(y_n)
    if game.pairs == 0:
        game.reveal_all()
        print(f"Total turns: {game.turns} | Total scores: {game.scores}")
        print("Congratulation!")

def easy():
    # Initialize game with 4x3 board
    game = Game(rows=4, cols=3, seed=None)
    os.system(clear) # Clear the screen before starting the game

    # Main game loop: continues until all pairs are matched
    while game.pairs != 0:
        game.board_print()

        # First reveal with cheat code check
        f_reveal = input("First Reveal: ")
        if f_reveal == "111":  # Cheat code to EXIT
            os.system(clear)
            break
 
        while f_reveal not in game.pos_lst or f_reveal == "":
            os.system(clear)
            print("Invalid input, try again")
            game.board_print()
            f_reveal = input("First Reveal: ")

        # Re-check for the cheat code in case the player re-enters it
        if f_reveal == "111":
            os.system(clear)
            break

        os.system(clear)
        game.first_reveal(f_reveal)

        # Second reveal with validation
        s_reveal = input("Next Reveal: ")
        while s_reveal not in game.pos_lst or s_reveal == "" or s_reveal == f_reveal:
            os.system(clear)
            print("Invalid input, try again")
            game.first_reveal(f_reveal)
            s_reveal = input("Next Reveal: ")

        os.system(clear)
        # Show match result and prompt to continue
        if game.second_reveal(f_reveal, s_reveal):
            _ = input("Press Enter to Continue")
        else:
            _ = input("Finish memorizing?(Press Enter to Continue)")
        os.system(clear)

        # Offer hint if player is struggling
        y_n = ""
        if game.hint_check():
            y_n = input("It seems like you are in trouble, do you want some hints?[y/n]")
            game.hint(y_n)

     # End game message       
    if game.pairs == 0:
        game.reveal_all()
        print(f"Total turns: {game.turns} | Total scores: {game.scores}")
        print("Good job! One step closer to Memory Master!")
    

def medium():
    # Initialize game with 4x4 board
    clear = "clear"
    game = Game(rows=4, cols=4, seed=None)
    os.system(clear)

    # Main loop until all pairs are matched
    while game.pairs != 0:
        game.board_print()

        # First reveal with cheat code check
        f_reveal = input("First Reveal: ")
        if f_reveal == "111":  # Cheat code
            os.system(clear)
            break
        while f_reveal not in game.pos_lst or f_reveal == "":
            os.system(clear)
            print("Invalid input, try again")
            game.board_print()
            f_reveal = input("First Reveal: ")

        if f_reveal == "111": # Re-check cheat code
            os.system(clear)
            break

        os.system(clear)
        game.first_reveal(f_reveal)

        # Second reveal with validation
        s_reveal = input("Next Reveal: ")
        while s_reveal not in game.pos_lst or s_reveal == "" or s_reveal == f_reveal:
            os.system(clear)
            print("Invalid input, try again")
            game.first_reveal(f_reveal)
            s_reveal = input("Next Reveal: ")

        os.system(clear)
        # Show match result, trigger tornado condition if matched
        if game.second_reveal(f_reveal, s_reveal):
            game.tornado_condition()
            _ = input("Press Enter to Continue")
        else:
            if not game.tornado_condition():
                game.switch_condition(2)
            _ = input("Finish memorizing?(Press Enter to Continue)")
        os.system(clear)

        # Offer hint if player is struggling
        if game.hint_check():
            y_n = input("It seems like you are in trouble, do you want some hints?[y/n]")
            game.hint(y_n)

    # End game message
    if game.pairs == 0:
        game.reveal_all()
        print(f"Total turns: {game.turns} | Total scores: {game.scores}")
        print("Remarkable! ! Almost a Memory Master!!")


def hard():
    # Initialize game with 4x6 board
    game = Game(rows=4, cols=6, seed=None)
    os.system(clear)

    # Main loop until all pairs are matched
    while game.pairs != 0:
        game.board_print()

        # First reveal with cheat code check
        f_reveal = input("First Reveal: ")
        if f_reveal == "111":  # Cheat code
            os.system(clear)
            break
        while f_reveal not in game.pos_lst or f_reveal == "":
            os.system(clear)
            print("Invalid input, try again")
            game.board_print()
            f_reveal = input("First Reveal: ")


        if f_reveal == "111": # Re-check cheat code
            os.system(clear)
            break

        os.system(clear)
        game.first_reveal(f_reveal)

        # Second reveal with validation
        s_reveal = input("Next Reveal:")
        while s_reveal not in game.pos_lst or s_reveal == "" or s_reveal == f_reveal:
            os.system(clear)
            print("Invalid input, try again")
            game.first_reveal(f_reveal)
            s_reveal = input("Next Reveal: ")

        os.system(clear)
        # Show match result, trigger tornado condition if matched
        if game.second_reveal(f_reveal, s_reveal):
            game.tornado_condition()
            _ = input("Press Enter to Continue")
        else:
            # Trigger switch effect if no tornado and no match
            if not game.tornado_condition():
                game.switch_condition(3)
            _ = input("Finish memorizing?(Press Enter to Continue)")
        os.system(clear)


    # End game message
    if game.pairs == 0:
        game.reveal_all()
        print(f"Total turns: {game.turns} | Total scores: {game.scores}")
        print("Splendid!!! You are a Memory Master now!!!")


def tutorial():
    game = Game(4, 4, seed=5)
    rolling("Welcome to Memory Master Tutorial \nHere I will teach you how to play the game")
    time.sleep(1.5)
    rolling("In the game, you will be given a board like this:")
    game.board_print() # Display the initial game board
    time.sleep(1.5)
    rolling("You can reveal a position on it to see what's under it, now try to type '1A' ")
    game.board_print() # Show the board again for user input
    f_reveal = input("First Reveal: ")

    if f_reveal != "1A":  # Check if the input is correct
        os.system("clear")
        game.board_print()
        print("Man! Two characters are not that hard! Let's assume you type '1A' ")
        time.sleep(2)
        f_reveal = "1A" # Assume the correct input for tutorial
        print("First Reveal: 1A")
        time.sleep(2)

    rolling("After you type '1A', you can see the position 1A is revealed:")
    game.first_reveal(f_reveal) # Reveal the first position
    time.sleep(2)
    rolling("Now, try to reveal another position, let's try '3C' this time")
    game.first_reveal(f_reveal)  # Display the first reveal again
    s_reveal = input("Next Reveal: ")

    if s_reveal != "3C":   # Check if the second input is correct
        os.system("clear")
        game.board_print()
        print("A mistake I guess? Let's assume you type '3C' ")
        time.sleep(2)
        s_reveal = "3C"  # Assume the correct input for tutorial
        print("Next Reveal: 3C")
        time.sleep(2)

    os.system("clear")

    rolling("Now you can see, you succesfully match up the two symbols, you get 100 score and have 7 pairs left to match up\nCombo means how many pairs you match up in a row, if you get more combo, you will have more scores for that turn", t= 0.06)
    game.second_reveal(f_reveal, s_reveal) # Process the second reveal
    time.sleep(1.5)
    _ = input("Finish reading? (Press Enter to Continue)")
    rolling("Then, the two position you succesfully match up will be changed to '√' on the board")
    game.board_print() # Show the updated board
    time.sleep(2)
    rolling("Try to match up every pair in as few turns as possible, the less turn you use, the better your grade(in the game) will be")
    time.sleep(1.5)
    rolling("In the game there are some special events that will occur, such as sometimes you can answer question to get a hint")
    time.sleep(1.5)
    rolling("In medium and hard level, there will be random swap and tornado(every row will 'rotate') to increase difficulty\nYou will know when you see them happen")
    time.sleep(1.5)
    rolling("Easy game, isn't it? Now you can go back to title to try to go through every level, \nor you can go to customize to create your own board with changable rows and columns")
    time.sleep(1)
    rolling("Good luck!")
    _ = input("Press Enter to Exit") # Wait for user to exit


class Game:
    def __init__(self, rows, cols, symbols = "☾◇♡⊚◬✫", seed=5):
        # Initialize game settings and board state
        if seed:
            random.seed(seed)
        self.rev_board = None
        self.scores = 0
        self.turns = 0
        self.combo = 0
        self.rows = rows
        self.cols = cols
        pairs = (rows * cols) // 2
        self.pairs = pairs
        color_codes = [31, 33, 34, 35, 36, 37]
        cards = []
        self.revealed = set()
        self.tornado_occur = False
        self.hint_counter = 0
        self.hint_req = 5

        # Set up questions for hints
        self.questions = {
            "Which year is UEFA Euro 2020 held? ": "2021",
            "Who published theory of relativity? ": "albert einstein",
            "Which city is the capital of france? ": "paris"}
        self.hints_left = len(self.questions)


       # Position and card setup
        self.pos_lst = []
        for i in range(self.rows):
            for j in range(self.cols):
                char = chr(65 + j)
                self.pos_lst.append(f"{i + 1}{char}")
        
        self.pos_lst0 = self.pos_lst[:]

        self.pos_to_num = {}
        index = 0
        for pos in self.pos_lst:
            self.pos_to_num.update({pos: index})
            index += 1


        # Assign colors and symbols to cards
        for c in color_codes:
            for symbol in symbols:
                cards.append(color(c, symbol))

        cards = cards[:pairs]
        self.pos = cards + cards
        random.shuffle(self.pos)
        self.board = ["x" for _ in range(pairs * 2)]

    def board_print(self, board=None):
        # Print the current game board with stats
        if not board:
            board = self.board
        print(f"Turns: {self.turns} | Pairs left: {self.pairs} | Scores: {self.scores}")
        print("      ", end="")

        for i in range(self.cols - 1):
            print(chr(65 + i), end="   ")
        print(chr(65 + self.cols - 1))

        for i in range(self.rows):
            print(f"{i + 1}  :  ", end='')
            for j in range(self.cols - 1):
                print(board[j + i * self.cols], end=" | ")
            print(board[self.cols - 1 + i * self.cols])


    def first_reveal(self, pos): #Reveal the first position
        rev_board = self.board[:]
        rev_board[self.pos_to_num[pos]] = self.pos[self.pos_to_num[pos]]
        self.board_print(rev_board)


    def second_reveal(self, pos1, pos2): # Process the second reveal and update score if matched
        self.turns += 1
        self.hint_check()

        rev_board = self.board[:]
        index1 = self.pos_to_num[pos1]
        index2 = self.pos_to_num[pos2]

        rev_board[index1] = self.pos[index1]
        rev_board[index2] = self.pos[index2]

        self.revealed.add(pos1)
        self.revealed.add(pos2)


        if rev_board[index1] == rev_board[index2]: #if two reveal are the same
            self.revealed.remove(pos1)
            self.revealed.remove(pos2)
            self.pairs -= 1 #pairs-1
            self.combo += 1 #combo+1
            inc = int((self.combo + 1) * self.combo / 2) * 100 #the increase in points
            self.scores += inc #increase the total score
            self.board_print(rev_board)
            print(f"Correct! Combo: {self.combo} -> +{inc} Score")
            self.board[index1] = "√"
            self.board[index2] = "√"
            self.pos_lst[index1] = ""
            self.pos_lst[index2] = ""
            self.hint_counter = 0
            return True
        else:
            self.combo = 0
            self.board_print(rev_board)
            return False
    
    def switch_condition(self, probability):
        # Trigger card switch with a given probability
        if not (len(self.revealed) == 0 or self.pairs <= 1 or random.randrange(1, 10) > probability):
            self.switching()

    def switching(self):
        # Randomly switch two cards on the board
        switch_pos1 = random.choice(list(self.revealed))
        lst = []
        lst.append(switch_pos1)
        switch_pos2 = random.choice(list(set(self.pos_lst0) - set(lst)))
        pos1 = self.pos_to_num[switch_pos1]
        pos2 = self.pos_to_num[switch_pos2]
        self.board[pos1], self.board[pos2] = self.board[pos2], self.board[pos1]
        self.pos[pos1], self.pos[pos2] = self.pos[pos2], self.pos[pos1]
        print('--------------------------------------------')
        print(f"A random switching occurs between {switch_pos1} and {switch_pos2}.")
        print('--------------------------------------------')
        self.pos_lst_update()

    def tornado_condition(self):
        # Trigger tornado effect at a quarter progress
        if ((self.rows * self.cols) / 2 - self.pairs) == len(self.pos) // 4 and not self.tornado_occur:
            self.tornado()
            return True
        return False

    def tornado(self):
         
        print('-----------------------------------------------------------------------------------------------------------------------------')
        print(f"A tornado will happen after pressing Enter: each card moves one step backward and the last card in a row moves to the front.")
        print('-----------------------------------------------------------------------------------------------------------------------------')

        _ = input("Press Enter to Continue")
        os.system('clear')
        self.board_print()
        time.sleep(1)
        os.system('clear')

        # Create a 2D representation of the board
        modified_board = [self.board[i * self.cols:(i + 1) * self.cols] for i in range(self.rows)] 

        # Shift positions of cards in each row
        for i in range(0, len(self.pos), self.cols):
            end = self.pos[i + self.cols - 1]
            for j in range(self.cols - 1, 0, -1):
                self.pos[i + j] = self.pos[i + j - 1]
            self.pos[i] = end

        # Shift cards in the board similarly
        for i in range(0, len(self.board), self.cols):
            end = self.board[i + self.cols - 1]
            for j in range(self.cols - 1, 0, -1):
                self.board[i + j] = self.board[i + j - 1]
            self.board[i] = end

        self.tornado_occur = True
        self.pos_lst_update() # Update position list

       # Display the board after the tornado effect
        for blank_pos in range(self.cols - 1, -1, -1):
            print(f"Turns: {self.turns} | Pairs left: {self.pairs} | Scores: {self.scores}")
            print("      ", end="")

            # Print column headers
            for i in range(self.cols - 1):
                print(chr(65 + i), end="   ")
            print(chr(65 + self.cols - 1))

             # Print each row with a blank space added for effect
            for i in range(self.rows):
                print(f"{i + 1}  :  ", end='')
                modified_row = modified_board[i][:blank_pos] + [" "] + modified_board[i][blank_pos:]
                row_str = " | ".join(map(str, modified_row))
                print(row_str)

            time.sleep(1)
            os.system('clear')

        self.board_print()

    
    def pos_lst_update(self):
        # Update positions for revealed cards
        self.pos_lst = self.pos_lst0[:]
        for i in range(len(self.board)):
            if self.board[i] == "√":
                self.pos_lst[i] = ""

    def reveal_all(self):  # Reveal the entire board at game end
        self.board_print(self.pos)

    def ask_question(self): # Ask a random question to gain a hint
        question, answer = random.choice(list(self.questions.items()))
        user_answer = input(f"Answer this to get hint: {question}").strip().lower()
        del self.questions[question]
        return user_answer == answer

    def hint(self, y_n):
        # Provide a hint if the player opts in
        self.hint_counter = 0
        if y_n.lower() == "y":
            positions = []
            for i, pos in enumerate(self.pos_lst):
                if pos != "":
                    positions.append(pos)
                    sym = self.pos[i]
                    index = i
                    break
            for i, syms in enumerate(self.pos):
                if syms == sym and self.pos_lst[i] not in positions:
                    positions.append(self.pos_lst[i])

            if self.ask_question():
                print(f"Hint: Try revealing {positions[0]} and {positions[1]}")
                self.hints_left -= 1
                return
    
    def hint_check(self):
        #Check if a hint is needed based on hint request counter
        if self.hint_counter == self.hint_req*2 and self.hints_left != 0:
            return True
        else:
            self.hint_counter += 1
            return False




def color(color_code, char, background=None): #For coloring text, code is the color code and char is the character or string being colored
    if not background:
        return "\33[{code}m".format(code=color_code) + char + "\33[{code}m".format(code=0)

def rolling(line, code = ">", t = 0.05, skip = [" "]):
# Animate printing of `line` based on `code` direction and delay `t

    if code == "<": # Reverse direction
        for i in range(len(line)-1, -1, -1):
            os.system("clear")
            print(line[i:])
            if line[i] not in skip:
                time.sleep(t)  # Pause for non-skipped characters
    else:  # Forward direction
        for i in range(1, len(line)):
            os.system("clear")
            print(line[:i+1])
            if line[i] not in skip:
                time.sleep(t)

if __name__ == "__main__":
    main()


